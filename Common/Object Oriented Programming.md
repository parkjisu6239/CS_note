## Object Oriented Programming

- 객체지향 프로그램 ?

  프로그래밍에서 필요한 데이터를 추상화시켜 `상태` 와 `행위` 를 가진 객체를 만들고, 그 객체들간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.

  - 객체 지향 프로그래밍의 오퍼레이션
    - 인터페이스 : 객체가 제공하는 모든 오퍼레이션의 집합, 객체를 사용하기 위한 명세
    - 메시지 : 메서드
    - 책임 : 객체마다 자신만이 제공할 수 있는 기능에 대한 책임이 있으며 작을 수록 좋다
  - 객체 지향적 설계 원칙?
    1. SRP(Single Responsibility Principle) : 단일 책임 원칙클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.
    2. OCP(Open-Closed Principle) : 개방-폐쇄 원칙확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
    3. LSP(Liskov Substitution Principle) : 리스코프 치환 원칙상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
    4. ISP(Interface Segregation Principle) : 인터페이스 분리 원칙인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
    5. DIP(Dependency Inversion Principle) : 의존 역전 원칙고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.
  - 객체 지향의 장점?
    - 코드 재사용이 용이 : 클래스 import, export가 가능하며 상속을 통해 확장 가능
    - 유지 보수가 쉬움 : 수정할 부분이 클래스 내부의 변수 혹은 메서드로 해당 부분만 수정
    - 대형 프로젝트에 적합 : 모듈화하여 작은 단위로 개발할 수 있으며, 업무 분담이 쉽다
  - 객체 지향의 단점 ?
    - 처리 속도가 상대적으로 느리다
    - 객체가 많으면 용량이 커질 수 있다
    - 설계시 많은 시간과 노력이 필요하다.
    - 상속을 통한 재사용의 단점
      - 상위 클래스 변경이 어려움 : 상위 클래스가 변경되면 이를 상속하는 여러 의존 클래스에도 모두 영향을 끼치게 된다.
      - 클래스의 불필요한 증가 : 유사한 기능을 확장하는 과정에서 클래스의 개수가 불필요하게 증가 할 수 있다.
      - 상속의 오용 : 같은 종류가 아닌 클래스를 상속받는 경우
      - 위와 같은 문제를 해소하기 위한 방법으로 `객체 조립` 이 있지만 상속보다 구현이 어렵고, 런타임 구조가 복잡해진다.
  - 객체 지향 프로그래밍의 키워드 5가지
    - 클래스 + 인스턴스
      - 클래스 : 어떤 문제를 해결하기 위한 데이터를 만들기 위해 속성, 행위를 변수, 메서드로 정의한 것이다. 객체를 만들기 위한 메타 정보라고 볼 수 있다.
      - 인스턴스(객체) : 클래스에서 정의한 것을 토대로 실제 메모리에 할당된 것
    - 추상화
      - 공통의 속성이나 기능을 묶어 이름을 붙이는 것
      - 클래스를 정의하는 행위를 추상회라고 할 수 있다.
    - 캡슐화
      - 변수 + 함수를 하나의 단위로 묶는 데이터 번들링, 클래스를 생성하는 것
        - 내부 기능이 변하더라도, 그 기능을 사용하는 코드는 변하지 않는다
        - 내부 구현 변경의 유연함을 주는 방식
      - 접근 제어자(public, private 등)을 통해 정보은닉
    - 상속
      - 상위 개념의 특징을 하위 개념이 물려 받은 것
      - 부모 클래스의 속성과 기능을 그대로 이어 받아, 일부를 수정하거나 추가할 경우 자식 클래스에서 필요한 부분만을 재정의 하여 사용할 수 있게 하는 것
      - 클래스 상속 관계에 혼란을 줄 수 있기때문에 다중 상속을 불가능하다.
    - 다형성
      - 하나의 변수 또는 함수가 상황에 따라 다른 의미로 해석될 수 있는 것을 의미
      - 부모 클래스에서 물려 받은 가상 함수를 자식 클래스 내에서 오버라이딩, 오버로딩하여 사용하는 것
        - 오버라이딩 : 부모클래스의 메서드와 같은 이름, 매개변수를 재정의 하는 것
        - 오버로딩 : 같은 이름의 함수를 여러개 정의하고, 매개변수 타입과 개수를 다르게 하여 매개변수에 따라 다르게 호출 할 수 있게 하는 것
  - getter, setter를 사용하는 이유?
    - 멤버 변수에 직접 접근 하지 못하게 private로 접근 지정자를 설정하고 public으로 getter, setter를 만들어 사용한다.
    - getter, setter등의 메서드를 통한 접근으로, 매서드 안에서 올바르지 않은 입력에 대해 사전에 처리 할 수 있게 제한하거나 조절할 수 있다.



------

[ 참고 사항 ]

- [원본](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Development_common_sense#object-oriented-programming)

