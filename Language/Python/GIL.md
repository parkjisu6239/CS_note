- **GIL 과 그로인한 성능 문제**

  `GIL(Global Interpreter Lock)` 은 python 객체가 다중 스레드에서 동시에 실행되지 않도록 하는 것이다. 파이썬의 **핵심 단점**이자 **한계**로 많이 언급된다. 이를 피하기 위해, 멀티스레드 대신 멀티프로세스를 사용하기도 한다.

  GIL 때문에 성능 문제가 대두되는 경우는 압축, 정렬, 인코딩 등 수행시간에 CPU 의 영향이 큰 작업(CPU bound)을 멀티 스레드로 수행하도록 한 경우다. 이 땐 GIL 때문에 멀티 스레드로 작업을 수행해도 싱글 스레드일 때와 별반 차이가 나지 않는다. 이를 해결하기 위해선 멀티 스레드는 파일, 네트워크 IO 같은 IO bound 프로그램에 사용하고 멀티 프로세스를 활용해야한다.

  - **GIL(Global Interpreter Lock)**

    스레드에서 사용되는 Lock 을 인터프리터 레벨로 확장한 개념인데 여러 스레드가 동시에 실행되는걸 방지한다. 더 정확히 말하자면 어느 시점이든 하나의 Bytecode 만이 실행되도록 강제한다. 각 스레드는 다른 스레드에 의해 GIL 이 해제되길 기다린 후에야 실행될 수 있다. 즉 멀티 스레드로 만들었어도 본질적으로 싱글 스레드로 동작한다.

  - 단점

    멀티스레드를 사용해도, GIL 때문에 한번에 하나의 스레드만 사용이 가능하고(나머지는 lock 걸리기 때문) 그와중에 멀티스레드를 사용했기때문에 context switch를 해야되서 시간이 더 드는 아이러니한 상황 → 멀티스레딩의 장점을 잃고 단점만 취한 느낌?

    - 그리고 무조건 느린 것은 아니다.
      - `sleep` 을 적절히 사용하면 멀티스레드가 더 빠르다.
      - 싱글스레이드에는 아무 동작을 취하지 못하기 대기하는 반면
      - 멀티스레드에서는 `sleep` 으로 멈춘다음, 다른 스레드로 스위칭 하여 효율이 개선된다.

  - 그럼 왜 쓰나?

    python은 기본적으로 garbage collection과 reference counting을 통해 할당된 메모리를 관리합니다. 따라서 파이썬의 모든 객체는 refernce count, 즉 해당 변수가 참조된 수를 저장하고 있습니다.

    멀티스레드인 경우 여러 스레드가 하나의 객체를 사용한다면 reference count를 관리하기 위해서 모든 객체에 대한 lock이 필요할 것입니다.

    이러한 비효율을 막기 위해서 python에서 GIL을 사용하게 되었습니다.

    하나의 Lock을 통해서 모든 객체들에 대한 refernce count의 동기화 문제를 해결한 것이죠.

  - 장점

    - GIL 을 활용한 멀티 스레드가 그렇지 않은 멀티 스레드보다 구현이 쉬우며
    - 레퍼런스 카운팅을 사용하는 메모리 관리 방식에서 GIL 덕분에 오버헤드가 적어 싱글 스레드일 때 [fine grained lock 방식](http://fileadmin.cs.lth.se/cs/education/eda015f/2013/herlihy4-5-presentation.pdf)보다 성능이 우월하다.
    - 또한 C extension 을 활용할 때 GIL 은 해제되므로 C library 를 사용하는 CPU bound 프로그램을 멀티 스레드로 실행하는 경우 더 빠를 수 있다.

    > python 3.8부터는 서브 인터프리터와 같은 기능들이 제안되면서 독립적인 GIL을 갖게해서 해당 문제를 해결하려는 움직임을 보이고 있다.