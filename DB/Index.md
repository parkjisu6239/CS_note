# **Index**

색인, 페이지 번호, 라벨링의 개념. 테이블의 각 레코드에 번호를 붙여 O(1)의 복잡도로 접근하게 한다. 읽기 속도를 올리기 위해 사용한다. 하지만 삽입, 삭제는 다소 느려질 수 있다.

- **Index 자료구조**

  - B+-Tree 알고리즘

    - 일반적로 많이 사용된다.
    - 칼럼의 값을 변형하지 않고, 원래의 값을 이용해 인덱싱하는 알고리즘이다.

  - **Hash 인덱스 알고리즘**

    - 칼럼값으로 해시값을 계산하는 방법. 매우 빠른 검색을 지원
    - 값을 변형해서 인덱싱하므로, 특정 문자로 시작하는 레코드가 많아 전방 일치와 같이 값의 일부만으로 검색할 때는 해시 인덱스를 사용할 수 없다.
    - 메모리 기반의 DB에서 많이 사용

  - **왜 index 를 생성하는데 b-tree 를 사용하는가?**

    데이터에 접근하는 시간복잡도가 O(1)인 hash table 이 더 효율적일 것 같은데? SELECT 질의의 조건에는 부등호(<>) 연산도 포함이 된다. hash table 을 사용하게 된다면 등호(=) 연산이 아닌 부등호 연산의 경우에 문제가 발생한다. 동등 연산(=)에 특화된 `hashtable`은 데이터베이스의 자료구조로 적합하지 않다.

- **Primary Index vs Secondary Index**

  - 비슷한 값을 가진 클러스터(물리적으로 인접한 위치)를 묶어서 저장
  - 프라이머리키에 대해서만 적용된다. pk가 비슷한 레코드끼리 묶어서 저장하는 것이 클러스터 인덱스
  - pk 순서로 저장위치가 결정되기 때문에 pk가 중요
  - 클러스터드 인덱스는 테이블당 한개만 생성 가능, pk에 대해서만 적용되기 때문에

- **Composite Index**

  인덱스로 설정하는 필드의 속성이 중요하다. title, author 이 순서로 인덱스를 설정한다면 title 을 search 하는 경우, index 를 생성한 효과를 볼 수 있지만, author 만으로 search 하는 경우, index 를 생성한 것이 소용이 없어진다. 따라서 SELECT 질의를 어떻게 할 것인가가 인덱스를 어떻게 생성할 것인가에 대해 많은 영향을 끼치게 된다.

- **Index 의 성능과 고려해야할 사항**

  - Index는 DB의 조회 기능을 빠르게 한다.
  - 하지만 추가, 제거, 삭제 쿼리를 실행할 때 별도의 과정이 발생한다.
  - DELETE 의 경우 INDEX 에 존재하는 값은 삭제하지 않고 사용 안한다는 표시로 남게 된다. 즉 row 의 수는 그대로인 것이다.
  - UPDATE 의 경우는 이전 데이터가 삭제되고 그 자리에 새 데이터가 들어오는 개념이기 때문이다. 즉 변경 전 데이터는 삭제되지 않고 insert 로 인한 split 도 발생하게 된다.
  - 컬럼을 이루고 있는 데이터의 형식에 따라서 인덱스의 성능이 악영향을 미칠 수 있다는 것이다.
  - 필드값중에서 최대한 중복된 데이터가 없고 독립적인것을 택한다.
