# 메모리 관리 전략

한정된 메모리에 여러 프로세스를 효율적으로 실행하기 위한 전략

- Swapping
  - 선점형 스케쥴링에서 기존에 작업을 진행하던 프로세스를 메모리에서 내쫒는 것
  - 혹은 메모리가 꽉 차서 특정 프로세스를 내쫒는 것
  - 주기억 장치에서 보조기억 장치로 스왑한다
- Fragmentation
  - 프로세스들이 메모리에 올랐다가 내렸다가 하나 보면 (외부/내부) 조각이 생긴다. 이걸 단편화라고 한다.
  - 외부 단편화(외부 조각) : 메모리 공간중 사용하지 못하는 부분. 여러 곳에 흩어져있다. 모이면 프로세스 하나 더 돌릴 수 있는데 흩어져서 안됨 → 낭비,
    - 하지만 이 메모리를 할당할 작은 프로세스가 있으면 그 프로세스는 실행 가능
    - 또는 `압축` 방법을 써서 분산된 메모리 파티션을 정리 할 수 있는데, 여기에 시간이 많이 들어서 효율적이지 않다.
  - 내부 단편화(내부 조각) : 하나의 프로세스가 할당 받은 메모리 중에 남는 부분. 하나의 파티션에는 하나의 프로세스만 적재 가능해서, 남는 부분은 다른 프로세스가 절대로 쓸수 없다(현재 프로세스가 메모리 차지 하는 동안에는)
- Paging
  - 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법이다.
  - 물리 메모리는 `Frame` 이라는 고정 크기로 분리되어 있고, 논리 메모리(프로세스가 점유하는)는 `페이지`라 불리는 고정 크기의 블록으로 분리된다.(페이지 교체 알고리즘에 들어가는 페이지)
  - 페이징 기법을 사용함으로써 논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치됨으로 외부 단편화를 해결할 수 있는 큰 장점이 있다. 해당 페이지의 인덱스만 저장되어 있으면 되기 때문
  - 하나의 프로세스가 사용하는 공간은 여러개의 페이지로 나뉘어서 관리되고(논리 메모리에서), 개별 페이지는 **순서에 상관없이** 물리 메모리에 있는 프레임에 mapping 되어 저장된다고 볼 수 있다.
  - 장점 : 외부 단편화 문제 해소
  - 단점 : 내부 단편화 문제의 비중이 늘어나게 된다.
- Segmentation
  - 페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, `서로 다른 크기`의 `논리적 단위`인 세그먼트(Segment)로 분할
  - 사용자가 두 개의 주소로 지정(세그먼트 번호 + 변위 offset) 세그먼트 테이블에는 각 세그먼트의 기준(세그먼트의 시작 물리 주소)과 한계(세그먼트의 길이)를 저장
  - 장점 : 프로세스의 의미있는 단위로 나누고, 그 크기로 나누어서 내부조각을 거의 줄일 수 있다.
  - 단점 : 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 자유 공간들이 많은 수의 작은 조각들로 나누어져 못 쓰게 될 수도 있다. (외부 단편화)