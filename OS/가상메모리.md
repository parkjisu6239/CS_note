# 가상 메모리

실제 물리적 메모리보다 큰 프로세스를 실행하기 위해 사용. 프로세스 전체를 메모리에 올리는 것이 아니라, 지금 당장 실행할 부분만 실제 메모리에 올리는 것. 프로그램이 물리메모리보다 커 도 됨. ram은 8, 16GB지만 그보다 많은 양을 동시에 실행하고 있음

- **장점**

  - 물리 메모리 크기에 제약을 받지 않는다.
  - 더 많은 프로그램을 동시 실행할 수 있어 응답 시간은 유지되고, CPU 이용률과 처리율이 높아진다.
  - 스왑을 적게하여 프로그램들이 빠르게 실행된다.

- **가상 메모리가 하는 일**

  물리 메모리, 논리 메모리를 분리한 것. 실제 프로세스가 위치한 메모리 주소와는 별개로, 가상의 주소 공간을 부여 받는다.

  - 가상 주소 공간
    - 프로세스가 물리적으로 저장된 것 처럼 논리적인 가상 메모리 주소 공간을 만든다.
    - 현재 실행되지 않는 부분은 실제 물리 메모리에 올리지 않는다.
  - 프로세스간 페이지 공유
    - 시스템 라이브러리가 여러 프로세스들 사이에 공유될 수 있도록 한다.
    - 공통적으로 사용하는 파일을 물리 메모리 페이지에 매핑되어 모든 프로세서가 공유한다.
    - 실제로 이를 사용할 때는 각 프로세스의 데이터 영역에 fork 하여 사용한다.

- **Demand Paging (요구 페이징)**

  - 초기에 필요한 부분만을 메모리에 적재하는 것
  - 그리고 이때 메모리는 페이지로 관리된다.
  - 가상 메모리를 페이지로 분할하여 프로세스를 나누어 할당하고, 필요한 경우 그 페이지만 메모리에 올린다.
  - **그래서 한번도 사용하지 않는 페이지는 물리메모리에 적재되지 않는다.**
  - 프로세서의 개별 페이지는 `페이저`에 의해 관리되고, 페이저가 실제 사용하는 페이지만 물리 메모리에 적재한다. 덕분에 시간낭비 메모리 낭비를 줄인다.

- **페이지 교체**

  프로세스의 동작에 필요한 페이지를 메모리에 적재하는 과정에서 `페이지 부재` 가 발생하게 되면, 원하는 페이지를 보조기억장치에서 가져오게 된다. 하지만 물리 메모리가 꽉 찬 상태라면 현재 메모리에 적재된 페이지의 일부를 내려한다. 이것이 페이지 교체. 그러면 어떤 페이지를 내릴 것인가?

  - 페이지 교체 방법
    1. 디스크에서 필요한 페이지의 위치를 찾는다
    2. 빈 페이지 프레임을 찾는다.
       1. `페이지 교체 알고리즘`을 통해 희생될(victim) 페이지를 고른다.
       2. 희생될 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정한다.
    3. 새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다.
    4. 사용자 프로세스 재시작

  아래는 페이지 교체 알고리즘

  - **FIFO**

    - 먼저 들어온 것을 내보낸다.
    - 장점 : 쉽다
    - 단점
      - 자주 사용되었거나, 최근에 사용되었는지는 고려하지 않는다.
      - `Belady의 모순`: 페이지를 저장할 수 있는 페이지 프레임의 갯수를 늘려도 되려 페이지 부재가 더 많이 발생하는 모순이 존재한다.

  - **Optimal Page Replacement**

    `Belady의 모순`을 확인한 이후 최적 교체 알고리즘에 대한 탐구가 진행되었고, 모든 알고리즘보다 낮은 페이지 부재율을 보이며 `Belady의 모순`이 발생하지 않는다. 이 알고리즘의 핵심은 `앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체`하는 것이다. 주로 비교 연구 목적을 위해 사용한다.

    - 장점
      - 알고리즘 중 가장 낮은 페이지 부재율을 보장한다.
    - 단점
      - 구현의 어려움이 있다. 모든 프로세스의 메모리 참조의 계획을 미리 파악할 방법이 없기 때문이다.

  - **LRU 페이지 교체(LRU Page Replacement)**

    최적 알고리즘의 근사 알고리즘으로, 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다.

    - 특징
      - 대체적으로 `FIFO 알고리즘`보다 우수하고, `OPT알고리즘`보다는 그렇지 못한 모습을 보인다.

  - **LFU 페이지 교체(LFU Page Replacement)**

    `LFU: Least Frequently Used`참조 횟수가 가장 적은 페이지를 교체하는 방법이다. 활발하게 사용되는 페이지는 참조 횟수가 많아질 거라는 가정에서 만들어진 알고리즘이다.

    - 특징
      - 어떤 프로세스가 특정 페이지를 집중적으로 사용하다, 다른 기능을 사용하게되면 더 이상 사용하지 않아도 계속 메모리에 머물게 되어 초기 가정에 어긋나는 시점이 발생할 수 있다. 초반에만 엄청 많이 쓰고, 나중에는 절대 안쓰는 경우 이 페이지는 내려가지 않는다.
      - 최적(OPT) 페이지 교체를 제대로 근사하지 못하기 때문에, 잘 쓰이지 않는다.

  - **MFU 페이지 교체(MFU Page Replacement)**

    `MFU: Most Frequently Used` 참조 회수가 가장 작은 페이지가 최근에 메모리에 올라왔고, 앞으로 계속 사용될 것이라는 가정에 기반한다.

    - 특징
      - 최적(OPT) 페이지 교체를 제대로 근사하지 못하기 때문에, 잘 쓰이지 않는다.